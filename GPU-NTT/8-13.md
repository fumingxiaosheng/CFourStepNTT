## 性能比较

*是我自己实现的，单位为微秒

主体思路是复用64维以下的NTT，64维NTT实现见64维NTT代码

| 维度n | 12 | 17 | 24 |
| :-----: | :-----: | :-----: | :-----: |
|   土耳其 4_step NTT | **13.12** = 2.69(转置) + 5.79(128个32维NTT + 转置) + 4.64(32个128维度NTT) | **47.58** = 7.87(转置) + 12.35(4096个32维NTT + 转置) + 12.03(32个4096维NTT部分1) + 15.33(32个4096维NTT部分2) |**4290** = 4.29 * 1000= 0.69（转置） + 1.13(65536个256维NTT + 转置) + 1.24(256个65536NTT前半部分) + 1.23(256个65536NTT后半部分)|
|   我的 4_step NTT(*) | **10.63** = 2.66(转置) + 4.51(64个64维NTT + 转置) + 3.46(64个64维NTT) |  **59.41** = 7.87(转置) + 12.03(4096个32维NTT + 转置) + 9.79(4096个4096维转置 + n修正因子) + 10.78(2048个64维NTT) + 8.16(4096个4096维转置 + 4096修正因子) +10.78(2048个64维NTT) |**8600** = 8.6 * 1000 = 0.7($2^{12}$转置) + 0.65(4096个4096维转置) + 1.07(65536个64维NTT) + 0.65(4096个4096维转置 + 乘修正因子) + 1.07(65536个64维NTT) + 0.7($2^{12}$转置) + + 0.97(4096个4096维转置 + 乘修正因子) + 1.07(65536个64维NTT) +0.65(4096个4096维转置 + 乘修正因子) + 1.07(65536个64维NTT)|

**复用64维NTT的思想在n=12上展现出了优越性，但是随着维数的升高，转置次数变多，优越性被掩盖**

## 64维NTT代码

假设需要做x个64维NTT，则polynomial_in的结构为x*64
线程组织结构为dim3(x/4,batch_size),dim3(32,4)
每个block完成4个64维NTT，一个Warp协同完成64维NTT，无需线程同步

```cpp
__global__ void FourStepFowardCore12_2(Data* polynomial_in,Root * n64_root_of_unity_table, Root *n64_W_inverse_root_of_unity_table, Root * W_root_of_unity_table, int mod_count ,int n_power, Modulus* modulus){
    __shared__ Data coes[4][64];

    int i=0;
    int q_index = blockIdx.y % mod_count; //moduls共用一个
    Modulus q_thread = modulus[q_index];//q_thread代表的是模数
    int global_start = blockIdx.x * 64 * blockDim.y + (blockIdx.y << n_power );

    coes[threadIdx.y][threadIdx.x] = polynomial_in[global_start + (threadIdx.y << 6) + threadIdx.x]; 
    coes[threadIdx.y][threadIdx.x + 32] = polynomial_in[global_start + (threadIdx.y << 6) + threadIdx.x + 32];

#pragma unroll
    for(i=5;i>=0;i--){

        CooleyTukeyUnit_(coes[threadIdx.y][((threadIdx.x >> i) << (i+1)) + (threadIdx.x & ((1<<i)-1))], coes[threadIdx.y][((threadIdx.x >> i) << (i+1)) + (threadIdx.x & ((1<<i)-1)) + (1<<i)], n64_root_of_unity_table[threadIdx.x >> i], q_thread);

    }
    //32个线程完成,无需进行syncthreads();
    
    polynomial_in[global_start + (threadIdx.y << 6) + threadIdx.x] = coes[threadIdx.y][threadIdx.x];
    polynomial_in[global_start + (threadIdx.y << 6) + threadIdx.x + 32] = coes[threadIdx.y][threadIdx.x + 32];

}
```

# 问题
1.转置
2.维度
3.写好benchmerk的
4.为什么解决了存储体冲突，时间还是没有有效得到提升